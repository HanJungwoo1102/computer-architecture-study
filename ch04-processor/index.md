# 프로세서

## Contents

1. [서론][link1]
2. [논리 설계 관례][link2]
3. [데이터패스 만들기][link3]
4. [단순한 구현][link4]

## 1. 서론

* 프로세서가 어떻게 구현되어 있는지 공부해 봅시다!
* <details><summary>공부 순서는??</summary>

  - 간단 버전 부터 봅니다 -> MIPS 명령어 집합 구현에 충분한 프로세서 구현 방법
    - 모든 mips 명령어 구현은 X (부동소수점 명령어는 아예 설명 X)
    - 핵심되는 원리 설명하고 나머지는 비슷하다.
  - 그 다음 좀 더 현실적인 버전 봅시다 -> 파이프라인 MIPS 구현방법 
  - 마지막으로 복잡한 버전 -> x86 같은 좀 더 복잡한 명령어 집합 구현 방법
</details>

* 구현에 대한 개요
  - <details><summary>명령어 마다 공통적으로 처리해야 하는 일이 상당히 많이 있다.</summary>
  
    - 단순하고 규칙적인 특성으로 구현을 단순화 했다.
    - 어떤 명령어 든지 처음 두 단계는 똑 같다.
      1. PC 에 있는 주소 찾아서 메모리에서 명령어 가져오기.
      2. 명령어 읽오서 한 개 또는 두 개의 레지스터를 읽는다.
    - 점프 명령어 제외한 모든 명령어 종류가 레지스터 읽은 후에 ALU 를 사용
      - 산술/논리 명령어는 연산하기 위해서 사용
      - 분기 명령어는 비교하기 위해
    - ALU 사용 후에 명령어 실행 끝내는데 필요한 행동
      - 메모리 참조 명령어는 메모리에 접근할 것.
      - 산술/논리 명령어는 연산한 거 레지스터에 저장
      - 분기 명령어는 pc 값 변화 시켜서 명령어 이동시킨다.
  </details>
  
  - <details><summary>흐름을 제어해야 한다.</summary>
    - 기능 유닛과 control 유닛
    - 기능 유닛 다 연결해 놓으면 동시에 다른 데이터가 들어오게 된다.
    - 근원지 여러 개, 입력이 여러 개면 그 중 하나 선택해야한다.
    - multiplexor: 다수의 흐름을 하나로 제어해주는 녀석
  </details>

## 2. 논리 설계 관례

* 논리 회로 복습 시간~
* <details><summary>조합 소자, 상태 소자</summary>

  - 조합 소자: combinational element
    - 입력 값에 따라 출력 됨
    - ALU
  - 상태 소자: state element
    - 상태 갖고 있음
    - 명령어 memory, 데이터 memory, 레지스터
</details>

* <details><summary>클러킹 방법론</summary>

  - 신호를 언제 읽고 언제 쓸 것인가!
  - 엣지 구동 클러킹 (edge-triggered clocking)
</details>

[link1]: #user-content-1-서론
[link2]: #user-content-2-논리-설계-관례
[link3]: #user-content-3-데이터패스-만들기
[link4]: #user-content-4-단순한-구현
